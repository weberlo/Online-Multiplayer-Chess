/*
 * Copyright (c) 2016, Jeff Hlywa (jhlywa@gmail.com)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 *----------------------------------------------------------------------------*/

/* minified license below  */

/* @license
 * Copyright (c) 2016, Jeff Hlywa (jhlywa@gmail.com)
 * Released under the BSD license
 * https://github.com/jhlywa/chess.js/blob/master/LICENSE
 */

 'use strict';

var Chess = function() {

  /* jshint indent: false */

  var WHITE = '0';
  var BLACK = '1';

  var EMPTY = -1;

  var PAWN = 'p';
  var KNIGHT = 'n';
  var BISHOP = 'b';
  var ROOK = 'r';
  var QUEEN = 'q';
  var KING = 'k';

  var SYMBOLS = 'pnbrqk';

  // var START_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';

  // const START_POSITION = [
  //   ['r0', 'n0', 'b0', 'q0', 'k0', 'b0', 'n0', 'r0'],
  //   ['p0', 'p0', 'p0', 'p0', 'p0', 'p0', 'p0', 'p0'],
  //   ['',    '',   '',   '',   '',   '',   '',   ''],
  //   ['',    '',   '',   '',   '',   '',   '',   ''],
  //   ['',    '',   '',   '',   '',   '',   '',   ''],
  //   ['',    '',   '',   '',   '',   '',   '',   ''],
  //   ['p1', 'p1', 'p1', 'p1', 'p1', 'p1', 'p1', 'p1'],
  //   ['r1', 'n1', 'b1', 'q1', 'k1', 'b1', 'n1', 'r1'],
  // ];
  const START_POSITION = [
    ['', '', '', '',   '',   '',   '',   '',   '',   '',   '',   '', '', '', '', ''],
    ['', '', '', '',   '',   '',   '',   '',   '',   '',   '',   '', '', '', '', ''],
    ['', '', '', '',   '',   '',   '',   '',   '',   '',   '',   '', '', '', '', ''],
    ['', '', '', '',   '',   '',   '',   '',   '',   '',   '',   '', '', '', '', ''],
    ['', '', '', '', 'r0', 'n0', 'b0', 'q0', 'k0', 'b0', 'n0', 'r0', '', '', '', ''],
    ['', '', '', '', 'p0', 'p0', 'p0', 'p0', 'p0', 'p0', 'p0', 'p0', '', '', '', ''],
    ['', '', '', '', '',    '',   '',   '',   '',   '',   '',   '' , '', '', '', ''],
    ['', '', '', '', '',    '',   '',   '',   '',   '',   '',   '' , '', '', '', ''],
    ['', '', '', '', '',    '',   '',   '',   '',   '',   '',   '' , '', '', '', ''],
    ['', '', '', '', '',    '',   '',   '',   '',   '',   '',   '' , '', '', '', ''],
    ['', '', '', '', 'p1', 'p1', 'p1', 'p1', 'p1', 'p1', 'p1', 'p1', '', '', '', ''],
    ['', '', '', '', 'r1', 'n1', 'b1', 'q1', 'k1', 'b1', 'n1', 'r1', '', '', '', ''],
    ['', '', '', '',   '',   '',   '',   '',   '',   '',   '',   '', '', '', '', ''],
    ['', '', '', '',   '',   '',   '',   '',   '',   '',   '',   '', '', '', '', ''],
    ['', '', '', '',   '',   '',   '',   '',   '',   '',   '',   '', '', '', '', ''],
    ['', '', '', '',   '',   '',   '',   '',   '',   '',   '',   '', '', '', '', '']
  ];
  const NUM_ROWS = START_POSITION.length;
  const NUM_COLS = START_POSITION[0].length;

  var POSSIBLE_RESULTS = ['1-0', '0-1', '1/2-1/2', '*'];

  var PAWN_OFFSETS = {
    b: [16, 32, 17, 15],
    w: [-16, -32, -17, -15]
  };

  var PIECE_OFFSETS = {
    n: [-18, -33, -31, -14,  18, 33, 31,  14],
    b: [-17, -15,  17,  15],
    r: [-16,   1,  16,  -1],
    q: [-17, -16, -15,   1,  17, 16, 15,  -1],
    k: [-17, -16, -15,   1,  17, 16, 15,  -1]
  };

  var ATTACKS = [
    20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20, 0,
     0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,
     0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,
     0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,
     0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,
    24,24,24,24,24,24,56,  0, 56,24,24,24,24,24,24, 0,
     0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,
     0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,
     0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,
     0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,
    20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20
  ];

  var RAYS = [
     17,  0,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0,  0, 15, 0,
      0, 17,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0, 15,  0, 0,
      0,  0, 17,  0,  0,  0,  0, 16,  0,  0,  0,  0, 15,  0,  0, 0,
      0,  0,  0, 17,  0,  0,  0, 16,  0,  0,  0, 15,  0,  0,  0, 0,
      0,  0,  0,  0, 17,  0,  0, 16,  0,  0, 15,  0,  0,  0,  0, 0,
      0,  0,  0,  0,  0, 17,  0, 16,  0, 15,  0,  0,  0,  0,  0, 0,
      0,  0,  0,  0,  0,  0, 17, 16, 15,  0,  0,  0,  0,  0,  0, 0,
      1,  1,  1,  1,  1,  1,  1,  0, -1, -1,  -1,-1, -1, -1, -1, 0,
      0,  0,  0,  0,  0,  0,-15,-16,-17,  0,  0,  0,  0,  0,  0, 0,
      0,  0,  0,  0,  0,-15,  0,-16,  0,-17,  0,  0,  0,  0,  0, 0,
      0,  0,  0,  0,-15,  0,  0,-16,  0,  0,-17,  0,  0,  0,  0, 0,
      0,  0,  0,-15,  0,  0,  0,-16,  0,  0,  0,-17,  0,  0,  0, 0,
      0,  0,-15,  0,  0,  0,  0,-16,  0,  0,  0,  0,-17,  0,  0, 0,
      0,-15,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,-17,  0, 0,
    -15,  0,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,  0,-17
  ];

  var SHIFTS = { p: 0, n: 1, b: 2, r: 3, q: 4, k: 5 };

  var FLAGS = {
    NORMAL: 'n',
    CAPTURE: 'c',
    BIG_PAWN: 'b',
    EP_CAPTURE: 'e',
    PROMOTION: 'p',
    KSIDE_CASTLE: 'k',
    QSIDE_CASTLE: 'q'
  };

  var BITS = {
    NORMAL: 1,
    CAPTURE: 2,
    BIG_PAWN: 4,
    EP_CAPTURE: 8,
    PROMOTION: 16,
    KSIDE_CASTLE: 32,
    QSIDE_CASTLE: 64
  };

  var RANK_1 = 7;
  var RANK_2 = 6;
  var RANK_3 = 5;
  var RANK_4 = 4;
  var RANK_5 = 3;
  var RANK_6 = 2;
  var RANK_7 = 1;
  var RANK_8 = 0;

  // var SQUARES = {
  //   a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,
  //   a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,
  //   a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,
  //   a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,
  //   a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,
  //   a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,
  //   a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,
  //   a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119
  // };

  // var ROOKS = {
  //   w: [{square: SQUARES.a1, flag: BITS.QSIDE_CASTLE},
  //       {square: SQUARES.h1, flag: BITS.KSIDE_CASTLE}],
  //   b: [{square: SQUARES.a8, flag: BITS.QSIDE_CASTLE},
  //       {square: SQUARES.h8, flag: BITS.KSIDE_CASTLE}]
  // };

  // var board = new Array(128);
  // var kings = {w: EMPTY, b: EMPTY};
  // var turn = WHITE;
  // var castling = {w: 0, b: 0};
  // var ep_square = EMPTY;
  // var half_moves = 0;
  // var move_number = 1;
  // var history = [];
  // var header = {};

  var board = null;
  var kings = null;
  var turn = null;
  var castling = null;
  var ep_square = null;
  var half_moves = null;
  var move_number = null;
  var history = null;
  var header = null;

  /* if the user passes in a fen string, load it, else default to
   * starting position
   */
  if (typeof fen === 'undefined') {
    load(START_POSITION);
  } else {
    load(fen);
  }

  function clear() {
    board = new Array(NUM_ROWS);
    for (let i = 0; i < board.length; i++) {
      board[i] = new Array(NUM_COLS);
      for (let j = 0; j < board[i].length; j++) {
        // need to set them to null otherwise the indices for empty entries
        // aren't even considered to be in the array (useful for `in` checks)
        board[i][j] = null;
      }
    }
    kings = {};
    kings[WHITE] = EMPTY;
    kings[BLACK] = EMPTY;
    turn = WHITE;
    castling = {};
    castling[WHITE] = 0;
    castling[BLACK] = 0;
    ep_square = EMPTY;
    half_moves = 0;
    move_number = 1;
    history = [];
    header = {};
  }

  function reset() {
    load(START_POSITION);
  }

  function load(pos) {
    // var tokens = fen.split(/\s+/);
    // var position = tokens[0];
    // var square = 0;

    clear();

    console.assert(pos.length == NUM_ROWS);
    console.assert(pos[0].length == NUM_COLS);

    for (let i = 0; i < NUM_ROWS; i++) {
      for (let j = 0; j < NUM_COLS; j++) {
        let piece = pos[i][j];
        let type = piece[0];
        let color = piece[1]
        put(i, j, {type: type, color: color});
      }
    }

    // for (var i = 0; i < position.length; i++) {
    //   var piece = position.charAt(i);

    //   if (piece === '/') {
    //     square += 8;
    //   } else if (is_digit(piece)) {
    //     square += parseInt(piece, 10);
    //   } else {
    //     square++;
    //   }
    // }

    // TODO parameterize
    turn = WHITE;

    // if (tokens[2].indexOf('K') > -1) {
    //   castling.w |= BITS.KSIDE_CASTLE;
    // }
    // if (tokens[2].indexOf('Q') > -1) {
    //   castling.w |= BITS.QSIDE_CASTLE;
    // }
    // if (tokens[2].indexOf('k') > -1) {
    //   castling.b |= BITS.KSIDE_CASTLE;
    // }
    // if (tokens[2].indexOf('q') > -1) {
    //   castling.b |= BITS.QSIDE_CASTLE;
    // }

    // ep_square = (tokens[3] === '-') ? EMPTY : SQUARES[tokens[3]];
    // half_moves = parseInt(tokens[4], 10);
    // move_number = parseInt(tokens[5], 10);

    return true;
  }

  function get(row, col) {
    var piece = board[row][col];
    return (piece) ? {type: piece.type, color: piece.color} : null;
  }

  function put(row, col, piece) {
    /* check for valid piece object */
    if (!('type' in piece && 'color' in piece)) {
      return false;
    }

    /* check for piece */
    if (SYMBOLS.indexOf(piece.type) === -1) {
      return false;
    }

    // var sq = SQUARES[square];

    // /* don't let the user place more than one king */
    // if (piece.type == KING &&
    //     !(kings[piece.color] == EMPTY || kings[piece.color] == sq)) {
    //   return false;
    // }

    board[row][col] = {type: piece.type, color: piece.color};
    if (piece.type === KING) {
      kings[piece.color] = [row, col];
    }

    return true;
  }

  function remove(row, col) {
    var piece = get(row, col);
    board[row][col] = null;
    if (piece && piece.type === KING) {
      kings[piece.color] = EMPTY;
    }

    return piece;
  }

  function build_move(board, from, to, flags, promotion) {
    var move = {
      color: turn,
      from: from,
      to: to,
      flags: flags,
      piece: board[from[0]][from[1]].type
    };

    if (promotion) {
      move.flags |= BITS.PROMOTION;
      move.promotion = promotion;
    }

    if (board[to[0]][to[1]]) {
      move.captured = board[to[0]][to[1]].type;
    } else if (flags & BITS.EP_CAPTURE) {
        move.captured = PAWN;
    }
    return move;
  }

  function generate_moves_single(row, col) {
    let us = turn;
    let them = swap_color(us);
    let second_rank = {};
    second_rank[WHITE] = RANK_2;
    second_rank[BLACK] = RANK_7;
    let piece = board[row][col];
    if (piece == null || piece.color !== us) {
      return [];
    }

    let res = [];

    // if (piece.type === PAWN) {
      // TODO add back double square initial move for pawns
      for (let [row_offs, col_offs] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {
        let dstRow = row + row_offs;
        let dstCol = col + col_offs;
        if (dstRow in board && dstCol in board[dstRow] && board[dstRow][dstCol] == null) {
          // add_move(board, moves, i, square, BITS.NORMAL);

          res.push(build_move(board, /* from */ [row, col], /* to */ [dstRow, dstCol], BITS.NORMAL));

          // /* double square */
          // var square = i + PAWN_OFFSETS[us][1];
          // if (second_rank[us] === rank(i) && board[square] == null) {
          //   add_move(board, moves, i, square, BITS.BIG_PAWN);
          // }
        }
      }
      return res;
      console.assert(false);

      // /* single square, non-capturing */
      // var square = i + PAWN_OFFSETS[us][0];
      // if (board[square] == null) {
      //   add_move(board, moves, i, square, BITS.NORMAL);

      //   /* double square */
      //   var square = i + PAWN_OFFSETS[us][1];
      //   if (second_rank[us] === rank(i) && board[square] == null) {
      //     add_move(board, moves, i, square, BITS.BIG_PAWN);
      //   }
      // }

      // /* pawn captures */
      // for (j = 2; j < 4; j++) {
      //   var square = i + PAWN_OFFSETS[us][j];
      //   if (square & 0x88) continue;

      //   if (board[square] != null &&
      //     board[square].color === them) {
      //     add_move(board, moves, i, square, BITS.CAPTURE);
      //   } else if (square === ep_square) {
      //     add_move(board, moves, i, ep_square, BITS.EP_CAPTURE);
      //   }
      // }
    // }
  }

  // function iterBoard(f) {
  //   board.forEach((row, rowIdx, rowArr) => {
  //     row.forEach((piece, colIdx, colArr) => {
  //       // TODO return list of results?
  //       f(rowIdx, colIdx, piece);
  //     });
  //   });
  // }

  function generate_moves(options) {
    // TODO(logan) support pawn promotion

    // function add_move(board, moves, from, to, flags) {
    //   /* if pawn promotion */
    //   if (board[from].type === PAWN &&
    //      (rank(to) === RANK_8 || rank(to) === RANK_1)) {
    //       var pieces = [QUEEN, ROOK, BISHOP, KNIGHT];
    //       for (var i = 0, len = pieces.length; i < len; i++) {
    //         moves.push(build_move(board, from, to, flags, pieces[i]));
    //       }
    //   } else {
    //     moves.push(build_move(board, from, to, flags));
    //   }
    // }

    var moves = [];

    /* do we want legal moves? */
    var legal = (typeof options !== 'undefined' && 'legal' in options) ?
                options.legal : true;

    if (typeof options !== 'undefined' && 'square' in options) {
      debugger;
      let [row, col] = options.square;
      return generate_moves_single(row, col);
    } else {
      // generate moves for every piece
      let moves = [];
      for (let row = 0; row < board.length; row++) {
        for (let col = 0; col < board[0].length; col++) {
          let currMoves = generate_moves_single(row, col)
          moves = moves.concat(currMoves);
        }
      }
      return moves;
    }


    // for (var i = first_sq; i <= last_sq; i++) {
    //   /* did we run off the end of the board */
    //   if (i & 0x88) { i += 7; continue; }

    //   var piece = board[i];
    //   if (piece == null || piece.color !== us) {
    //     continue;
    //   }

    //   if (piece.type === PAWN) {
    //     /* single square, non-capturing */
    //     var square = i + PAWN_OFFSETS[us][0];
    //     if (board[square] == null) {
    //         add_move(board, moves, i, square, BITS.NORMAL);

    //       /* double square */
    //       var square = i + PAWN_OFFSETS[us][1];
    //       if (second_rank[us] === rank(i) && board[square] == null) {
    //         add_move(board, moves, i, square, BITS.BIG_PAWN);
    //       }
    //     }

    //     /* pawn captures */
    //     for (j = 2; j < 4; j++) {
    //       var square = i + PAWN_OFFSETS[us][j];
    //       if (square & 0x88) continue;

    //       if (board[square] != null &&
    //           board[square].color === them) {
    //           add_move(board, moves, i, square, BITS.CAPTURE);
    //       } else if (square === ep_square) {
    //           add_move(board, moves, i, ep_square, BITS.EP_CAPTURE);
    //       }
    //     }
    //   } else {
    //     for (var j = 0, len = PIECE_OFFSETS[piece.type].length; j < len; j++) {
    //       var offset = PIECE_OFFSETS[piece.type][j];
    //       var square = i;

    //       while (true) {
    //         square += offset;
    //         if (square & 0x88) break;

    //         if (board[square] == null) {
    //           add_move(board, moves, i, square, BITS.NORMAL);
    //         } else {
    //           if (board[square].color === us) break;
    //           add_move(board, moves, i, square, BITS.CAPTURE);
    //           break;
    //         }

    //         /* break, if knight or king */
    //         if (piece.type === 'n' || piece.type === 'k') break;
    //       }
    //     }
    //   }
    // }

    // /* check for castling if: a) we're generating all moves, or b) we're doing
    //  * single square move generation on the king's square
    //  */
    // if ((!single_square) || last_sq === kings[us]) {
    //   /* king-side castling */
    //   if (castling[us] & BITS.KSIDE_CASTLE) {
    //     var castling_from = kings[us];
    //     var castling_to = castling_from + 2;

    //     if (board[castling_from + 1] == null &&
    //         board[castling_to]       == null &&
    //         !attacked(them, kings[us]) &&
    //         !attacked(them, castling_from + 1) &&
    //         !attacked(them, castling_to)) {
    //       add_move(board, moves, kings[us] , castling_to,
    //                BITS.KSIDE_CASTLE);
    //     }
    //   }

    //   /* queen-side castling */
    //   if (castling[us] & BITS.QSIDE_CASTLE) {
    //     var castling_from = kings[us];
    //     var castling_to = castling_from - 2;

    //     if (board[castling_from - 1] == null &&
    //         board[castling_from - 2] == null &&
    //         board[castling_from - 3] == null &&
    //         !attacked(them, kings[us]) &&
    //         !attacked(them, castling_from - 1) &&
    //         !attacked(them, castling_to)) {
    //       add_move(board, moves, kings[us], castling_to,
    //                BITS.QSIDE_CASTLE);
    //     }
    //   }
    // }

    /* return all pseudo-legal moves (this includes moves that allow the king
     * to be captured)
     */
    if (!legal) {
      return moves;
    }

    /* filter out illegal moves */
    var legal_moves = [];
    for (var i = 0, len = moves.length; i < len; i++) {
      make_move(moves[i]);
      if (!king_attacked(us)) {
        legal_moves.push(moves[i]);
      }
      undo_move();
    }

    return legal_moves;
  }

  /* convert a move from 0x88 coordinates to Standard Algebraic Notation
   * (SAN)
   *
   * @param {boolean} sloppy Use the sloppy SAN generator to work around over
   * disambiguation bugs in Fritz and Chessbase.  See below:
   *
   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4
   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned
   * 4. ... Ne7 is technically the valid SAN
   */
  function move_to_san(move, sloppy) {
    var output = '';

    if (move.flags & BITS.KSIDE_CASTLE) {
      output = 'O-O';
    } else if (move.flags & BITS.QSIDE_CASTLE) {
      output = 'O-O-O';
    } else {
      var disambiguator = get_disambiguator(move, sloppy);

      if (move.piece !== PAWN) {
        output += move.piece.toUpperCase() + disambiguator;
      }

      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {
        if (move.piece === PAWN) {
          output += algebraic(move.from)[0];
        }
        output += 'x';
      }

      output += algebraic(move.to);

      if (move.flags & BITS.PROMOTION) {
        output += '=' + move.promotion.toUpperCase();
      }
    }

    make_move(move);
    if (in_check()) {
      if (in_checkmate()) {
        output += '#';
      } else {
        output += '+';
      }
    }
    undo_move();

    return output;
  }

  // parses all of the decorators out of a SAN string
  function stripped_san(move) {
    return move.replace(/=/,'').replace(/[+#]?[?!]*$/,'');
  }

  function attacked(color, square) {
    return false;
    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {
      /* did we run off the end of the board */
      if (i & 0x88) { i += 7; continue; }

      /* if empty square or wrong color */
      if (board[i] == null || board[i].color !== color) continue;

      var piece = board[i];
      var difference = i - square;
      var index = difference + 119;

      if (ATTACKS[index] & (1 << SHIFTS[piece.type])) {
        if (piece.type === PAWN) {
          if (difference > 0) {
            if (piece.color === WHITE) return true;
          } else {
            if (piece.color === BLACK) return true;
          }
          continue;
        }

        /* if the piece is a knight or a king */
        if (piece.type === 'n' || piece.type === 'k') return true;

        var offset = RAYS[index];
        var j = i + offset;

        var blocked = false;
        while (j !== square) {
          if (board[j] != null) { blocked = true; break; }
          j += offset;
        }

        if (!blocked) return true;
      }
    }

    return false;
  }

  function king_attacked(color) {
    return attacked(swap_color(color), kings[color]);
  }

  function in_check() {
    return king_attacked(turn);
  }

  function in_checkmate() {
    return in_check() && generate_moves().length === 0;
  }

  function in_stalemate() {
    return !in_check() && generate_moves().length === 0;
  }

  function insufficient_material() {
    return false;
    var pieces = {};
    var bishops = [];
    var num_pieces = 0;
    var sq_color = 0;

    for (var i = SQUARES.a8; i<= SQUARES.h1; i++) {
      sq_color = (sq_color + 1) % 2;
      if (i & 0x88) { i += 7; continue; }

      var piece = board[i];
      if (piece) {
        pieces[piece.type] = (piece.type in pieces) ?
                              pieces[piece.type] + 1 : 1;
        if (piece.type === BISHOP) {
          bishops.push(sq_color);
        }
        num_pieces++;
      }
    }

    /* k vs. k */
    if (num_pieces === 2) { return true; }

    /* k vs. kn .... or .... k vs. kb */
    else if (num_pieces === 3 && (pieces[BISHOP] === 1 ||
                                 pieces[KNIGHT] === 1)) { return true; }

    /* kb vs. kb where any number of bishops are all on the same color */
    else if (num_pieces === pieces[BISHOP] + 2) {
      var sum = 0;
      var len = bishops.length;
      for (var i = 0; i < len; i++) {
        sum += bishops[i];
      }
      if (sum === 0 || sum === len) { return true; }
    }

    return false;
  }

  function in_threefold_repetition() {
    // TODO(logan) implement?
    return false;

    /* TODO: while this function is fine for casual use, a better
     * implementation would use a Zobrist key (instead of FEN). the
     * Zobrist key would be maintained in the make_move/undo_move functions,
     * avoiding the costly that we do below.
     */
    var moves = [];
    var positions = {};
    var repetition = false;

    while (true) {
      var move = undo_move();
      if (!move) break;
      moves.push(move);
    }

    while (true) {
      /* remove the last two fields in the FEN string, they're not needed
       * when checking for draw by rep */
      var fen = generate_fen().split(' ').slice(0,4).join(' ');

      /* has the position occurred three or move times */
      positions[fen] = (fen in positions) ? positions[fen] + 1 : 1;
      if (positions[fen] >= 3) {
        repetition = true;
      }

      if (!moves.length) {
        break;
      }
      make_move(moves.pop());
    }

    return repetition;
  }

  function push(move) {
    history.push({
      move: move,
      kings: {b: kings.b, w: kings.w},
      turn: turn,
      castling: {b: castling.b, w: castling.w},
      ep_square: ep_square,
      half_moves: half_moves,
      move_number: move_number
    });
  }

  function make_move(move) {
    var us = turn;
    var them = swap_color(us);
    push(move);

    board[move.to[0]][move.to[1]] = board[move.from[0]][move.from[1]];
    board[move.from[0]][move.from[1]] = null;

    // /* if ep capture, remove the captured pawn */
    // if (move.flags & BITS.EP_CAPTURE) {
    //   if (turn === BLACK) {
    //     board[move.to - 16] = null;
    //   } else {
    //     board[move.to + 16] = null;
    //   }
    // }

    // /* if pawn promotion, replace with new piece */
    // if (move.flags & BITS.PROMOTION) {
    //   board[move.to] = {type: move.promotion, color: us};
    // }

    // /* if we moved the king */
    // if (board[move.to].type === KING) {
    //   kings[board[move.to].color] = move.to;

    //   /* if we castled, move the rook next to the king */
    //   if (move.flags & BITS.KSIDE_CASTLE) {
    //     var castling_to = move.to - 1;
    //     var castling_from = move.to + 1;
    //     board[castling_to] = board[castling_from];
    //     board[castling_from] = null;
    //   } else if (move.flags & BITS.QSIDE_CASTLE) {
    //     var castling_to = move.to + 1;
    //     var castling_from = move.to - 2;
    //     board[castling_to] = board[castling_from];
    //     board[castling_from] = null;
    //   }

    //   /* turn off castling */
    //   castling[us] = '';
    // }

    // /* turn off castling if we move a rook */
    // if (castling[us]) {
    //   for (var i = 0, len = ROOKS[us].length; i < len; i++) {
    //     if (move.from === ROOKS[us][i].square &&
    //         castling[us] & ROOKS[us][i].flag) {
    //       castling[us] ^= ROOKS[us][i].flag;
    //       break;
    //     }
    //   }
    // }

    // /* turn off castling if we capture a rook */
    // if (castling[them]) {
    //   for (var i = 0, len = ROOKS[them].length; i < len; i++) {
    //     if (move.to === ROOKS[them][i].square &&
    //         castling[them] & ROOKS[them][i].flag) {
    //       castling[them] ^= ROOKS[them][i].flag;
    //       break;
    //     }
    //   }
    // }

    // /* if big pawn move, update the en passant square */
    // if (move.flags & BITS.BIG_PAWN) {
    //   if (turn === 'b') {
    //     ep_square = move.to - 16;
    //   } else {
    //     ep_square = move.to + 16;
    //   }
    // } else {
    //   ep_square = EMPTY;
    // }

    // /* reset the 50 move counter if a pawn is moved or a piece is captured */
    // if (move.piece === PAWN) {
    //   half_moves = 0;
    // } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {
    //   half_moves = 0;
    // } else {
    //   half_moves++;
    // }

    if (turn === BLACK) {
      move_number++;
    }
    turn = swap_color(turn);
  }

  function undo_move() {
    var old = history.pop();
    if (old == null) { return null; }

    var move = old.move;
    kings = old.kings;
    turn = old.turn;
    castling = old.castling;
    ep_square = old.ep_square;
    half_moves = old.half_moves;
    move_number = old.move_number;

    var us = turn;
    var them = swap_color(turn);

    board[move.from] = board[move.to];
    board[move.from].type = move.piece;  // to undo any promotions
    board[move.to] = null;

    if (move.flags & BITS.CAPTURE) {
      board[move.to] = {type: move.captured, color: them};
    } else if (move.flags & BITS.EP_CAPTURE) {
      var index;
      if (us === BLACK) {
        index = move.to - 16;
      } else {
        index = move.to + 16;
      }
      board[index] = {type: PAWN, color: them};
    }


    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {
      var castling_to, castling_from;
      if (move.flags & BITS.KSIDE_CASTLE) {
        castling_to = move.to + 1;
        castling_from = move.to - 1;
      } else if (move.flags & BITS.QSIDE_CASTLE) {
        castling_to = move.to - 2;
        castling_from = move.to + 1;
      }

      board[castling_to] = board[castling_from];
      board[castling_from] = null;
    }

    return move;
  }

  /* this function is used to uniquely identify ambiguous moves */
  function get_disambiguator(move, sloppy) {
    var moves = generate_moves({legal: !sloppy});

    var from = move.from;
    var to = move.to;
    var piece = move.piece;

    var ambiguities = 0;
    var same_rank = 0;
    var same_file = 0;

    for (var i = 0, len = moves.length; i < len; i++) {
      var ambig_from = moves[i].from;
      var ambig_to = moves[i].to;
      var ambig_piece = moves[i].piece;

      /* if a move of the same piece type ends on the same to square, we'll
       * need to add a disambiguator to the algebraic notation
       */
      if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {
        ambiguities++;

        if (rank(from) === rank(ambig_from)) {
          same_rank++;
        }

        if (file(from) === file(ambig_from)) {
          same_file++;
        }
      }
    }

    if (ambiguities > 0) {
      /* if there exists a similar moving piece on the same rank and file as
       * the move in question, use the square as the disambiguator
       */
      if (same_rank > 0 && same_file > 0) {
        return algebraic(from);
      }
      /* if the moving piece rests on the same file, use the rank symbol as the
       * disambiguator
       */
      else if (same_file > 0) {
        return algebraic(from).charAt(1);
      }
      /* else use the file symbol */
      else {
        return algebraic(from).charAt(0);
      }
    }

    return '';
  }

  /*****************************************************************************
   * UTILITY FUNCTIONS
   ****************************************************************************/

  function swap_color(c) {
    return c === WHITE ? BLACK : WHITE;
  }

  function is_digit(c) {
    return '0123456789'.indexOf(c) !== -1;
  }

  /* pretty = external move object */
  function make_pretty(ugly_move) {
    var move = clone(ugly_move);
    move.san = move_to_san(move, false);
    move.to = algebraic(move.to);
    move.from = algebraic(move.from);

    var flags = '';

    for (var flag in BITS) {
      if (BITS[flag] & move.flags) {
        flags += FLAGS[flag];
      }
    }
    move.flags = flags;

    return move;
  }

  function clone(obj) {
    var dupe = (obj instanceof Array) ? [] : {};

    for (var property in obj) {
      if (typeof property === 'object') {
        dupe[property] = clone(obj[property]);
      } else {
        dupe[property] = obj[property];
      }
    }

    return dupe;
  }

  function trim(str) {
    return str.replace(/^\s+|\s+$/g, '');
  }

  /*****************************************************************************
   * DEBUGGING UTILITIES
   ****************************************************************************/
  function perft(depth) {
    var moves = generate_moves({legal: false});
    var nodes = 0;
    var color = turn;

    for (var i = 0, len = moves.length; i < len; i++) {
      make_move(moves[i]);
      if (!king_attacked(color)) {
        if (depth - 1 > 0) {
          var child_nodes = perft(depth - 1);
          nodes += child_nodes;
        } else {
          nodes++;
        }
      }
      undo_move();
    }

    return nodes;
  }

  return {
    /***************************************************************************
     * PUBLIC CONSTANTS (is there a better way to do this?)
     **************************************************************************/
    WHITE: WHITE,
    BLACK: BLACK,
    PAWN: PAWN,
    KNIGHT: KNIGHT,
    BISHOP: BISHOP,
    ROOK: ROOK,
    QUEEN: QUEEN,
    KING: KING,
    // SQUARES: (function() {
    //             /* from the ECMA-262 spec (section 12.6.4):
    //              * "The mechanics of enumerating the properties ... is
    //              * implementation dependent"
    //              * so: for (var sq in SQUARES) { keys.push(sq); } might not be
    //              * ordered correctly
    //              */
    //             var keys = [];
    //             for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {
    //               if (i & 0x88) { i += 7; continue; }
    //               keys.push(algebraic(i));
    //             }
    //             return keys;
    //           })(),
    FLAGS: FLAGS,

    /***************************************************************************
     * PUBLIC API
     **************************************************************************/
    load: function(fen) {
      return load(fen);
    },

    reset: function() {
      return reset();
    },

    moves: function(options) {
      /* The internal representation of a chess move is in 0x88 format, and
       * not meant to be human-readable.  The code below converts the 0x88
       * square coordinates to algebraic coordinates.  It also prunes an
       * unnecessary move keys resulting from a verbose call.
       */

      return generate_moves(options);

      // var ugly_moves = generate_moves(options);
      // var moves = [];

      // for (var i = 0, len = ugly_moves.length; i < len; i++) {

      //   /* does the user want a full move object (most likely not), or just
      //    * SAN
      //    */
      //   if (typeof options !== 'undefined' && 'verbose' in options &&
      //       options.verbose) {
      //     moves.push(make_pretty(ugly_moves[i]));
      //   } else {
      //     moves.push(move_to_san(ugly_moves[i], false));
      //   }
      // }

      // return moves;
    },

    in_check: function() {
      return in_check();
    },

    in_checkmate: function() {
      return in_checkmate();
    },

    in_stalemate: function() {
      return in_stalemate();
    },

    in_draw: function() {
      return half_moves >= 100 ||
             in_stalemate() ||
             insufficient_material() ||
             in_threefold_repetition();
    },

    insufficient_material: function() {
      return insufficient_material();
    },

    in_threefold_repetition: function() {
      return in_threefold_repetition();
    },

    game_over: function() {
      return half_moves >= 100 ||
             in_checkmate() ||
             in_stalemate() ||
             insufficient_material() ||
             in_threefold_repetition();
    },

    ascii: function() {
      return ascii();
    },

    turn: function() {
      return turn;
    },

    move: function(move, options) {
      /* The move function can be called with in the following parameters:
       *
       * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string
       *
       * .move({ from: 'h7', <- where the 'move' is a move object (additional
       *         to :'h8',      fields are ignored)
       *         promotion: 'q',
       *      })
       */

      // allow the user to specify the sloppy move parser to work around over
      // disambiguation bugs in Fritz and Chessbase
      var sloppy = (typeof options !== 'undefined' && 'sloppy' in options) ?
                    options.sloppy : false;

      var move_obj = null;

      // NOTE for whatever reasoning, the map is generating a NaN, so we unfold
      // it manually below
      // move.from = move.from.split('-').map(parseInt);

      // let moveSrc = move.from.split('-');
      // moveSrc[0] = parseInt(moveSrc[0]);
      // moveSrc[1] = parseInt(moveSrc[1]);
      // move.from = moveSrc;

      // let moveDst = move.to.split('-');
      // moveDst[0] = parseInt(moveDst[0]);
      // moveDst[1] = parseInt(moveDst[1]);
      // move.to = moveDst;

      // move.to = move.to.split('-').map(parseInt);

      // if (typeof move === 'string') {
      //   move_obj = move_from_san(move, sloppy);
      // } else if (typeof move === 'object') {
        var moves = generate_moves();

        /* convert the pretty move object to an ugly move object */
        for (var i = 0, len = moves.length; i < len; i++) {
          // candidate
          let cand = moves[i];
          if (move.from[0] === cand.from[0] && move.from[1] === cand.from[1] &&
            move.to[0] === cand.to[0] && move.to[1] === cand.to[1] &&
            (!('promotion' in cand) ||
              move.promotion === cand.promotion)) {
            move_obj = cand;
            break;
          }
        }
      // }

      /* failed to find move */
      if (!move_obj) {
        return null;
      }

      // /* need to make a copy of move because we can't generate SAN after the
      //  * move is made
      //  */
      // var pretty_move = make_pretty(move_obj);

      make_move(move_obj);

      return move_obj;
    },

    currentPosition: function() {
      let boardCopy = new Array(NUM_ROWS);
      for (let i = 0; i < boardCopy.length; i++) {
        boardCopy[i] = new Array(NUM_COLS);
        for (let j = 0; j < boardCopy[i].length; j++) {
          // TODO make both chessboard.js and chess.js use same board repr
          let piece = board[i][j];
          if (piece == null) {
            boardCopy[i][j] = '';
          } else {
            boardCopy[i][j] = piece.type + piece.color;
          }
        }
      }
      return boardCopy;
    },

    undo: function() {
      return undo_move();
    },

    clear: function() {
      return clear();
    },

    put: function(row, col, piece) {
      return put(row, col, piece);
    },

    get: function(row, col) {
      return get(row, col);
    },

    remove: function(row, col) {
      return remove(row, col);
    },

    perft: function(depth) {
      return perft(depth);
    },

    history: function(options) {
      var reversed_history = [];
      var move_history = [];
      var verbose = (typeof options !== 'undefined' && 'verbose' in options &&
                     options.verbose);

      while (history.length > 0) {
        reversed_history.push(undo_move());
      }

      while (reversed_history.length > 0) {
        var move = reversed_history.pop();
        if (verbose) {
          move_history.push(make_pretty(move));
        } else {
          move_history.push(move_to_san(move));
        }
        make_move(move);
      }

      return move_history;
    }

  };
};

/* export Chess object if using node or any other CommonJS compatible
 * environment */
if (typeof exports !== 'undefined') exports.Chess = Chess;
/* export Chess object for any RequireJS compatible environment */
if (typeof define !== 'undefined') define( function () { return Chess;  });
